####
1. Look at the example of init code in today's notes See gist. When we do the CODECOPY operation, what are we overwriting ? (debugging this in Remix might help here)

https://www.ethervm.io/#39

The COPYCODE opcode is ovewriting (coping to) the memory with the executing contract's bytecode. 
Before the COPYCODE instruction the value in the memory is: 
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080

After there is the instruction PUSH1 with 00 instruction and the memory is: 
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

And after the COPYCODE the memory is: 
6080604052348015600f57600080fd5b506004361060285760003560e01c806357de26a414602d575b600080fd5b60336047565b604051603e91906067565b60405180910390f35b60008054905090565b6000819050919050565b6061816050565b82525050565b6000602082019050607a6000830184605a565b9291505056fea2646970667358221220cd1ba41d242097d3012a981a4f783078520e59a0629051d32062d7fe0760fd8564736f6c6343000813003300000000000000000000

That correspont with the bytecode from the previous operationsexecuted that where stored in the stack. 


####
2. Could the answer to Q1 allow an optimisation ?
